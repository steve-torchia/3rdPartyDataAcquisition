/*

NOTE:  The code in this file was generated by AI (GH Copilot/Claude Sonnet 4) based on an overly simple prompt: 
"How can I improve the unit tests in Acme.AcquireGeneration.Test?" 

I put this here as an example of how AI can be useful to generate test code, but it is not a complete solution by any means 
and requires human review and testing to ensure correctness.

It generated a lot of suggestions but the following work is the _minimum_ that would need to be done in order to make sure it is correct:

    1. Review the generated code for correctness and completeness.
    2. Run the tests to verify that they pass and behave as expected.
    3. Refactor the code as necessary to improve readability and maintainability.
    4. Ensure the code is consistent with the existing codebase and follows best practices.

At worst, the code could be completely wrong, so it is important to review it carefully before using it in production.
At best, it can provide a good _starting point_ for writing unit tests and can save time in the development process.

*/



using System;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Moq;
using Moq.Protected;
using Xunit;
using Acme.Contracts;
using Newtonsoft.Json;

namespace Acme.AcquireGeneration.Test
{
    public class AcmeHttpClientTests
    {
        private readonly Mock<ILogger<AcmeHttpClient>> _loggerMock;
        private readonly Mock<HttpMessageHandler> _httpMessageHandlerMock;
        private readonly HttpClient _httpClient;
        private readonly IOptions<AcmeSubscriptionInfo> _subscriptionInfo;

        public AcmeHttpClientTests()
        {
            _loggerMock = new Mock<ILogger<AcmeHttpClient>>();
            _httpMessageHandlerMock = new Mock<HttpMessageHandler>(MockBehavior.Strict);
            _httpClient = new HttpClient(_httpMessageHandlerMock.Object);
            
            _subscriptionInfo = Options.Create(new AcmeSubscriptionInfo
            {
                ApiInfo = new AcmeApiInfo
                {
                    BaseUrl = "https://api.acme.com",
                    SolarPath = "/solar",
                    WindPath = "/wind",
                    StatusPath = "/status"
                }
            });
        }

        [Fact]
        public async Task LaunchGenerationForWeatherYearJob_Wind_Success()
        {
            // Arrange
            var expectedHistoryId = "12345";
            var ctx = AcmeAcquireGenerationTestHelpers.GetDefaultCtx("wind");
            
            _httpMessageHandlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.Is<HttpRequestMessage>(req => 
                        req.Method == HttpMethod.Post && 
                        req.RequestUri.ToString().Contains("/wind")),
                    ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(expectedHistoryId)
                });

            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act
            var result = await client.LaunchGenerationForWeatherYearJob(ctx);

            // Assert
            Assert.True(result.Success);
            Assert.Equal(expectedHistoryId, result.ReturnValue);
        }

        [Fact]
        public async Task LaunchGenerationForWeatherYearJob_Solar_Success()
        {
            // Arrange
            var expectedHistoryId = "67890";
            var ctx = AcmeAcquireGenerationTestHelpers.GetDefaultCtx("solar");
            
            _httpMessageHandlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.Is<HttpRequestMessage>(req => 
                        req.Method == HttpMethod.Post && 
                        req.RequestUri.ToString().Contains("/solar")),
                    ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(expectedHistoryId)
                });

            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act
            var result = await client.LaunchGenerationForWeatherYearJob(ctx);

            // Assert
            Assert.True(result.Success);
            Assert.Equal(expectedHistoryId, result.ReturnValue);
        }

        [Fact]
        public async Task LaunchGenerationForWeatherYearJob_InvalidProduct_ThrowsException()
        {
            // Arrange
            var ctx = AcmeAcquireGenerationTestHelpers.GetDefaultCtx("wind");
            ctx.Project.Product = "InvalidProduct";
            
            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act & Assert
            await Assert.ThrowsAsync<Exception>(() => client.LaunchGenerationForWeatherYearJob(ctx));
        }

        [Fact]
        public async Task LaunchGenerationForWeatherYearJob_NullContext_ThrowsArgumentNullException()
        {
            // Arrange
            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act & Assert
            await Assert.ThrowsAsync<ArgumentNullException>(() => client.LaunchGenerationForWeatherYearJob(null));
        }

        [Fact]
        public async Task WaitForGenerationJobAsync_Completed_Success()
        {
            // Arrange
            var historyId = "12345";
            var resultsUrl = "https://acme.com/results/12345";
            var jobInfo = new AcmeJobInfo
            {
                Status = "Completed",
                ResultsUrl = resultsUrl
            };

            _httpMessageHandlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.Is<HttpRequestMessage>(req => 
                        req.Method == HttpMethod.Get && 
                        req.RequestUri.ToString().Contains($"/status/{historyId}")),
                    ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(JsonConvert.SerializeObject(jobInfo))
                });

            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act
            var result = await client.WaitForGenerationJobAsync(historyId, retryCount: 1);

            // Assert
            Assert.True(result.Success);
            Assert.Equal(resultsUrl, result.ReturnValue);
        }

        [Fact]
        public async Task WaitForGenerationJobAsync_Error_ReturnsFailure()
        {
            // Arrange
            var historyId = "12345";
            var jobInfo = new AcmeJobInfo
            {
                Status = "Error",
                Message = "Processing failed"
            };

            _httpMessageHandlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(JsonConvert.SerializeObject(jobInfo))
                });

            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act
            var result = await client.WaitForGenerationJobAsync(historyId, retryCount: 1);

            // Assert
            Assert.False(result.Success);
            Assert.Contains("Processing failed", result.ReturnValue);
        }

        [Fact]
        public async Task WaitForGenerationJobAsync_Timeout_ReturnsFailure()
        {
            // Arrange
            var historyId = "12345";
            var jobInfo = new AcmeJobInfo
            {
                Status = "Pending"
            };

            _httpMessageHandlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(JsonConvert.SerializeObject(jobInfo))
                });

            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act
            var result = await client.WaitForGenerationJobAsync(historyId, retryCount: 2, retryIntervalSeconds: 1);

            // Assert
            Assert.False(result.Success);
            Assert.Contains("TIMEOUT", result.ReturnValue);
        }

        [Theory]
        [InlineData("wind")]
        [InlineData("solar")]
        public void GetGenerationRequestUri_ValidProduct_ReturnsCorrectUri(string product)
        {
            // Arrange
            var ctx = AcmeAcquireGenerationTestHelpers.GetDefaultCtx(product);
            var client = new AcmeHttpClient(_httpClient, _loggerMock.Object, _subscriptionInfo);

            // Act & Assert - Using reflection to test private method
            var method = typeof(AcmeHttpClient).GetMethod("GetGenerationRequestUri", 
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
            var result = (Uri)method.Invoke(client, new object[] { ctx });

            var expectedPath = product == "wind" ? "/wind" : "/solar";
            Assert.Contains(expectedPath, result.ToString());
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                _httpClient?.Dispose();
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
